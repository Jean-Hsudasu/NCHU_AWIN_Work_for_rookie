<第1題>:
由於是窮舉法所以這題是以[0,0,0,0]開始，
雖然一定會找到答案，但由於是一個一個慢慢找答案，需要花費非常多時間
所以此演算法非常沒有效率，
諾資料量一大根本無法與其他演算法做比較

<第2題>:
這裡有參考了https://blog.csdn.net/a6225301/article/details/50497800
發現這個網站後，我大約花了幾分鐘去理解並寫出code，
這題對我的難度來說還可以接受，也很清楚每一步在做什麼

第一步:
隨機給一個字串 ex.[5,2,9]

第二步:
將此字串的x1~x3分別減1與加1 ex.[4,2,9]、[6,2,9]、[5,1,9].....
但要注意的是，不能超過預設0~9的範圍!!

第三步:
帶入方程式，挑出最小的解，並記下來

第四步:
回到第二部....

基本上如果是以4位數字來說通常在100次左右就會被算出來了

<第3題>:
這裡就是將圖畫出來而已，
我使用pyecahrts套件
可以看到到列舉法的效率真的非常差

<第4題>:
改成20位數..過

<第5題>:
這題我使用模擬退火演算法
我找了非常多的資料，
大至了解此演算法，
退火演算法的架構和爬山演算法非常相似，
所以這題我用第2題去做更改，
多了T(初始溫度)、Tmin(最低溫度)、
每次都將溫度*0.999
以爬山演算法來說比較的話，
雖然退火演算法有機會找到其他最佳解，
但也要剛好是T(溫度)高的時候，

<第6題>:
這題真的讓我想破頭也不知道要如何寫出來
我先找遺傳演算法
參考的網址是:https://morvanzhou.github.io/tutorials/machine-learning/evolutionary-algorithm/2-01-genetic-algorithm/
我的想法是:
首先產生一百組密碼(0~9)
並且帶入方程式輸出Y，產生第一組結果
在做交配與變異的動作，
但以只有(0與1)來說 這步比較輕鬆，但現在是(0~9)

這題我思考了很久...但真的花了太多時間去寫這一題


